#!/usr/bin/env python3
"""
Cross-language round-trip test for Go → Python protobuf validation.

This script reads protobuf files generated by Go tests and validates
that the data can be correctly decoded and matches expected values.
"""

import sys
import os
import json
import argparse
from pathlib import Path

# Add the current directory to Python path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    # Try to import ampy-proto (may not be available in all environments)
    from ampy.bars.v1 import bar_batch_pb2
    from ampy.ticks.v1 import quote_tick_pb2
    from ampy.fundamentals.v1 import fundamentals_snapshot_pb2
    AMPY_AVAILABLE = True
except ImportError:
    print("Warning: ampy-proto not available, skipping protobuf validation")
    AMPY_AVAILABLE = False

def validate_bars(test_type, identifier):
    """Validate bar batch protobuf data."""
    if not AMPY_AVAILABLE:
        print("Skipping bars validation - ampy-proto not available")
        return True
    
    pb_file = f"_rt/bars_{identifier}.pb"
    metadata_file = f"_rt/bars_{identifier}_metadata.json"
    
    if not os.path.exists(pb_file) or not os.path.exists(metadata_file):
        print(f"Missing files for bars test: {pb_file}, {metadata_file}")
        return False
    
    # Read metadata
    with open(metadata_file, 'r') as f:
        metadata = json.load(f)
    
    # Read and parse protobuf
    with open(pb_file, 'rb') as f:
        pb_data = f.read()
    
    try:
        bar_batch = bar_batch_pb2.BarBatch()
        bar_batch.ParseFromString(pb_data)
        
        # Validate basic structure
        assert len(bar_batch.bars) > 0, "No bars found in batch"
        
        bar = bar_batch.bars[0]
        
        # Validate security
        assert bar.security.symbol == metadata["security"]["symbol"], f"Symbol mismatch: {bar.security.symbol} != {metadata['security']['symbol']}"
        assert bar.security.mic == metadata["security"]["mic"], f"MIC mismatch: {bar.security.mic} != {metadata['security']['mic']}"
        
        # Validate price data with scale 2
        expected_open = metadata["bar"]["open"]
        assert bar.open.scaled == expected_open["scaled"], f"Open price mismatch: {bar.open.scaled} != {expected_open['scaled']}"
        assert bar.open.scale == expected_open["scale"], f"Open scale mismatch: {bar.open.scale} != {expected_open['scale']}"
        
        expected_close = metadata["bar"]["close"]
        assert bar.close.scaled == expected_close["scaled"], f"Close price mismatch: {bar.close.scaled} != {expected_close['scaled']}"
        assert bar.close.scale == expected_close["scale"], f"Close scale mismatch: {bar.close.scale} != {expected_close['scale']}"
        
        # Validate volume
        assert bar.volume == metadata["bar"]["volume"], f"Volume mismatch: {bar.volume} != {metadata['bar']['volume']}"
        
        print(f"✓ Bars validation passed for {identifier}")
        return True
        
    except Exception as e:
        print(f"✗ Bars validation failed for {identifier}: {e}")
        return False

def validate_quotes(test_type, identifier):
    """Validate quote protobuf data."""
    if not AMPY_AVAILABLE:
        print("Skipping quotes validation - ampy-proto not available")
        return True
    
    pb_file = "_rt/quote.pb"
    metadata_file = "_rt/quote_metadata.json"
    
    if not os.path.exists(pb_file) or not os.path.exists(metadata_file):
        print(f"Missing files for quote test: {pb_file}, {metadata_file}")
        return False
    
    # Read metadata
    with open(metadata_file, 'r') as f:
        metadata = json.load(f)
    
    # Read and parse protobuf
    with open(pb_file, 'rb') as f:
        pb_data = f.read()
    
    try:
        quote = quote_tick_pb2.QuoteTick()
        quote.ParseFromString(pb_data)
        
        # Validate security
        assert quote.security.symbol == metadata["security"]["symbol"], f"Symbol mismatch: {quote.security.symbol} != {metadata['security']['symbol']}"
        assert quote.security.mic == metadata["security"]["mic"], f"MIC mismatch: {quote.security.mic} != {metadata['security']['mic']}"
        
        # Validate bid/ask with scale 2
        expected_bid = metadata["quote"]["bid"]
        assert quote.bid.scaled == expected_bid["scaled"], f"Bid price mismatch: {quote.bid.scaled} != {expected_bid['scaled']}"
        assert quote.bid.scale == expected_bid["scale"], f"Bid scale mismatch: {quote.bid.scale} != {expected_bid['scale']}"
        
        expected_ask = metadata["quote"]["ask"]
        assert quote.ask.scaled == expected_ask["scaled"], f"Ask price mismatch: {quote.ask.scaled} != {expected_ask['scaled']}"
        assert quote.ask.scale == expected_ask["scale"], f"Ask scale mismatch: {quote.ask.scale} != {expected_ask['scale']}"
        
        # Validate sizes
        assert quote.bid_size == metadata["quote"]["bid_size"], f"Bid size mismatch: {quote.bid_size} != {metadata['quote']['bid_size']}"
        assert quote.ask_size == metadata["quote"]["ask_size"], f"Ask size mismatch: {quote.ask_size} != {metadata['quote']['ask_size']}"
        
        print(f"✓ Quote validation passed for {identifier}")
        return True
        
    except Exception as e:
        print(f"✗ Quote validation failed for {identifier}: {e}")
        return False

def validate_fundamentals(test_type, identifier):
    """Validate fundamentals protobuf data."""
    if not AMPY_AVAILABLE:
        print("Skipping fundamentals validation - ampy-proto not available")
        return True
    
    pb_file = "_rt/fundamentals.pb"
    metadata_file = "_rt/fundamentals_metadata.json"
    
    if not os.path.exists(pb_file) or not os.path.exists(metadata_file):
        print(f"Missing files for fundamentals test: {pb_file}, {metadata_file}")
        return False
    
    # Read metadata
    with open(metadata_file, 'r') as f:
        metadata = json.load(f)
    
    # Read and parse protobuf
    with open(pb_file, 'rb') as f:
        pb_data = f.read()
    
    try:
        fundamentals = fundamentals_snapshot_pb2.FundamentalsSnapshot()
        fundamentals.ParseFromString(pb_data)
        
        # Validate security
        assert fundamentals.security.symbol == metadata["security"]["symbol"], f"Symbol mismatch: {fundamentals.security.symbol} != {metadata['security']['symbol']}"
        
        # Validate lines
        assert len(fundamentals.lines) == len(metadata["lines"]), f"Line count mismatch: {len(fundamentals.lines)} != {len(metadata['lines'])}"
        
        for i, line in enumerate(fundamentals.lines):
            expected_line = metadata["lines"][i]
            assert line.key == expected_line["key"], f"Line {i} key mismatch: {line.key} != {expected_line['key']}"
            
            # Validate value with scale 2
            expected_value = expected_line["value"]
            assert line.value.scaled == expected_value["scaled"], f"Line {i} value mismatch: {line.value.scaled} != {expected_value['scaled']}"
            assert line.value.scale == expected_value["scale"], f"Line {i} scale mismatch: {line.value.scale} != {expected_value['scale']}"
            
            assert line.currency_code == expected_line["currency_code"], f"Line {i} currency mismatch: {line.currency_code} != {expected_line['currency_code']}"
        
        print(f"✓ Fundamentals validation passed for {identifier}")
        return True
        
    except Exception as e:
        print(f"✗ Fundamentals validation failed for {identifier}: {e}")
        return False

def validate_precision(test_type, identifier):
    """Validate numeric precision edge cases."""
    if not AMPY_AVAILABLE:
        print("Skipping precision validation - ampy-proto not available")
        return True
    
    pb_file = f"_rt/precision_{identifier}.pb"
    metadata_file = f"_rt/precision_{identifier}_metadata.json"
    
    if not os.path.exists(pb_file) or not os.path.exists(metadata_file):
        print(f"Missing files for precision test: {pb_file}, {metadata_file}")
        return False
    
    # Read metadata
    with open(metadata_file, 'r') as f:
        metadata = json.load(f)
    
    # Read and parse protobuf
    with open(pb_file, 'rb') as f:
        pb_data = f.read()
    
    try:
        bar_batch = bar_batch_pb2.BarBatch()
        bar_batch.ParseFromString(pb_data)
        
        assert len(bar_batch.bars) > 0, "No bars found in batch"
        
        bar = bar_batch.bars[0]
        
        # Validate that scale is 2 (not 4)
        assert bar.open.scale == 2, f"Expected scale 2, got {bar.open.scale}"
        assert bar.close.scale == 2, f"Expected scale 2, got {bar.close.scale}"
        
        # Validate that scaled values are reasonable for scale 2
        expected_price = metadata["expected_price"]
        expected_scaled = int(expected_price * 100)  # Scale 2 = * 100
        
        # Allow for small rounding differences
        assert abs(bar.open.scaled - expected_scaled) <= 1, f"Price precision mismatch: {bar.open.scaled} != {expected_scaled} (expected {expected_price})"
        
        print(f"✓ Precision validation passed for {identifier} (price: {expected_price}, scaled: {bar.open.scaled})")
        return True
        
    except Exception as e:
        print(f"✗ Precision validation failed for {identifier}: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Cross-language round-trip test')
    parser.add_argument('test_type', choices=['bars', 'quote', 'fundamentals', 'precision'], 
                       help='Type of test to run')
    parser.add_argument('identifier', help='Test identifier (currency, symbol, etc.)')
    
    args = parser.parse_args()
    
    # Change to the project root directory
    script_dir = Path(__file__).parent
    project_root = script_dir.parent.parent.parent
    os.chdir(project_root)
    
    success = False
    
    if args.test_type == 'bars':
        success = validate_bars(args.test_type, args.identifier)
    elif args.test_type == 'quote':
        success = validate_quotes(args.test_type, args.identifier)
    elif args.test_type == 'fundamentals':
        success = validate_fundamentals(args.test_type, args.identifier)
    elif args.test_type == 'precision':
        success = validate_precision(args.test_type, args.identifier)
    
    if success:
        print(f"✓ Cross-language round-trip test passed: {args.test_type}/{args.identifier}")
        sys.exit(0)
    else:
        print(f"✗ Cross-language round-trip test failed: {args.test_type}/{args.identifier}")
        sys.exit(1)

if __name__ == '__main__':
    main()
