#!/usr/bin/env python3
"""
Cross-language round-trip test for Go → Python protobuf compatibility.
This script reads protobuf files generated by Go and validates that
the decoded values match the expected metadata.
"""

import sys
import json
import os
from pathlib import Path

# Add the ampy-proto Python package to the path
# This would typically be installed via pip or added to PYTHONPATH
try:
    import ampy_proto
    from ampy_proto import bars_pb2, ticks_pb2, fundamentals_pb2
except ImportError:
    print("ERROR: ampy-proto Python package not found")
    print("Please install it with: pip install ampy-proto")
    sys.exit(1)


def test_bars_roundtrip(proto_file, meta_file):
    """Test bars protobuf round-trip."""
    # Read protobuf file
    with open(proto_file, 'rb') as f:
        proto_data = f.read()
    
    # Read metadata
    with open(meta_file, 'r') as f:
        metadata = json.load(f)
    
    # Decode protobuf
    bar_batch = bars_pb2.BarBatch()
    bar_batch.ParseFromString(proto_data)
    
    # Validate security
    assert bar_batch.security.symbol == metadata['security']['symbol']
    assert bar_batch.security.mic == metadata['security']['mic']
    
    # Validate bar data
    assert len(bar_batch.bars) == 1
    bar = bar_batch.bars[0]
    expected_bar = metadata['bar']
    
    # Validate price data
    assert bar.open.scaled == expected_bar['open']['scaled']
    assert bar.open.scale == expected_bar['open']['scale']
    assert bar.high.scaled == expected_bar['high']['scaled']
    assert bar.high.scale == expected_bar['high']['scale']
    assert bar.low.scaled == expected_bar['low']['scaled']
    assert bar.low.scale == expected_bar['low']['scale']
    assert bar.close.scaled == expected_bar['close']['scaled']
    assert bar.close.scale == expected_bar['close']['scale']
    
    # Validate other fields
    assert bar.volume == expected_bar['volume']
    assert bar.currency_code == expected_bar['currency']
    assert bar.adjusted == expected_bar['adjusted']
    
    # Validate timestamps (convert from Unix timestamp)
    import datetime
    expected_event_time = datetime.datetime.fromtimestamp(expected_bar['event_time'], tz=datetime.timezone.utc)
    actual_event_time = datetime.datetime.fromtimestamp(bar.event_time.seconds, tz=datetime.timezone.utc)
    assert actual_event_time == expected_event_time
    
    print(f"✓ Bars round-trip test passed for {metadata['security']['symbol']}")


def test_quote_roundtrip(proto_file, meta_file):
    """Test quote protobuf round-trip."""
    # Read protobuf file
    with open(proto_file, 'rb') as f:
        proto_data = f.read()
    
    # Read metadata
    with open(meta_file, 'r') as f:
        metadata = json.load(f)
    
    # Decode protobuf
    quote = ticks_pb2.Quote()
    quote.ParseFromString(proto_data)
    
    # Validate security
    assert quote.security.symbol == metadata['security']['symbol']
    assert quote.security.mic == metadata['security']['mic']
    
    # Validate quote data
    expected_quote = metadata['quote']
    
    # Validate price data
    assert quote.bid.scaled == expected_quote['bid']['scaled']
    assert quote.bid.scale == expected_quote['bid']['scale']
    assert quote.ask.scaled == expected_quote['ask']['scaled']
    assert quote.ask.scale == expected_quote['ask']['scale']
    
    # Validate other fields
    assert quote.bid_size == expected_quote['bid_size']
    assert quote.ask_size == expected_quote['ask_size']
    assert quote.currency_code == expected_quote['currency']
    assert quote.venue == expected_quote['venue']
    
    # Validate timestamps
    import datetime
    expected_event_time = datetime.datetime.fromtimestamp(expected_quote['event_time'], tz=datetime.timezone.utc)
    actual_event_time = datetime.datetime.fromtimestamp(quote.event_time.seconds, tz=datetime.timezone.utc)
    assert actual_event_time == expected_event_time
    
    print(f"✓ Quote round-trip test passed for {metadata['security']['symbol']}")


def test_fundamentals_roundtrip(proto_file, meta_file):
    """Test fundamentals protobuf round-trip."""
    # Read protobuf file
    with open(proto_file, 'rb') as f:
        proto_data = f.read()
    
    # Read metadata
    with open(meta_file, 'r') as f:
        metadata = json.load(f)
    
    # Decode protobuf
    fundamentals = fundamentals_pb2.Snapshot()
    fundamentals.ParseFromString(proto_data)
    
    # Validate security
    assert fundamentals.security.symbol == metadata['security']['symbol']
    assert fundamentals.security.mic == metadata['security']['mic']
    
    # Validate lines
    assert len(fundamentals.lines) == len(metadata['lines'])
    
    for i, line in enumerate(fundamentals.lines):
        expected_line = metadata['lines'][i]
        
        assert line.key == expected_line['key']
        assert line.value.scaled == expected_line['value']['scaled']
        assert line.value.scale == expected_line['value']['scale']
        assert line.currency_code == expected_line['currency']
        
        # Validate timestamps
        import datetime
        expected_start = datetime.datetime.fromtimestamp(expected_line['period_start'], tz=datetime.timezone.utc)
        expected_end = datetime.datetime.fromtimestamp(expected_line['period_end'], tz=datetime.timezone.utc)
        actual_start = datetime.datetime.fromtimestamp(line.period_start.seconds, tz=datetime.timezone.utc)
        actual_end = datetime.datetime.fromtimestamp(line.period_end.seconds, tz=datetime.timezone.utc)
        assert actual_start == expected_start
        assert actual_end == expected_end
    
    # Validate other fields
    assert fundamentals.source == metadata['source']
    
    import datetime
    expected_as_of = datetime.datetime.fromtimestamp(metadata['as_of'], tz=datetime.timezone.utc)
    actual_as_of = datetime.datetime.fromtimestamp(fundamentals.as_of.seconds, tz=datetime.timezone.utc)
    assert actual_as_of == expected_as_of
    
    print(f"✓ Fundamentals round-trip test passed for {metadata['security']['symbol']}")


def main():
    if len(sys.argv) != 4:
        print("Usage: python3 roundtrip_test.py <data_type> <proto_file> <meta_file>")
        print("  data_type: bars, quote, or fundamentals")
        print("  proto_file: path to .pb file")
        print("  meta_file: path to .json metadata file")
        sys.exit(1)
    
    data_type = sys.argv[1]
    proto_file = sys.argv[2]
    meta_file = sys.argv[3]
    
    # Validate files exist
    if not os.path.exists(proto_file):
        print(f"ERROR: Proto file not found: {proto_file}")
        sys.exit(1)
    
    if not os.path.exists(meta_file):
        print(f"ERROR: Metadata file not found: {meta_file}")
        sys.exit(1)
    
    try:
        if data_type == "bars":
            test_bars_roundtrip(proto_file, meta_file)
        elif data_type == "quote":
            test_quote_roundtrip(proto_file, meta_file)
        elif data_type == "fundamentals":
            test_fundamentals_roundtrip(proto_file, meta_file)
        else:
            print(f"ERROR: Unknown data type: {data_type}")
            print("Supported types: bars, quote, fundamentals")
            sys.exit(1)
        
        print("✓ All round-trip tests passed!")
        
    except Exception as e:
        print(f"ERROR: Round-trip test failed: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
