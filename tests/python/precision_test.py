#!/usr/bin/env python3
"""
Precision test for cross-language numeric compatibility.
This script validates that numeric precision is preserved
when decoding protobuf files generated by Go.
"""

import sys
import json
import os
from decimal import Decimal, getcontext

# Add the ampy-proto Python package to the path
try:
    import ampy_proto
    from ampy_proto import bars_pb2
except ImportError:
    print("ERROR: ampy-proto Python package not found")
    print("Please install it with: pip install ampy-proto")
    sys.exit(1)


def test_numeric_precision(proto_file, meta_file):
    """Test that numeric precision is preserved."""
    # Read protobuf file
    with open(proto_file, 'rb') as f:
        proto_data = f.read()
    
    # Read metadata
    with open(meta_file, 'r') as f:
        metadata = json.load(f)
    
    # Decode protobuf
    bar_batch = bars_pb2.BarBatch()
    bar_batch.ParseFromString(proto_data)
    
    # Get expected values from metadata
    expected_values = metadata['expected_values']
    expected_scaled = expected_values['scaled']
    expected_scale = expected_values['scale']
    
    # Get actual values from protobuf
    bar = bar_batch.bars[0]
    actual_scaled = bar.open.scaled
    actual_scale = bar.open.scale
    
    # Validate exact match
    assert actual_scaled == expected_scaled, f"Scaled value mismatch: expected {expected_scaled}, got {actual_scaled}"
    assert actual_scale == expected_scale, f"Scale mismatch: expected {expected_scale}, got {actual_scale}"
    
    # Test decimal conversion
    # Convert to decimal for precision testing
    expected_decimal = Decimal(expected_scaled) / (Decimal(10) ** expected_scale)
    actual_decimal = Decimal(actual_scaled) / (Decimal(10) ** actual_scale)
    
    assert actual_decimal == expected_decimal, f"Decimal conversion mismatch: expected {expected_decimal}, got {actual_decimal}"
    
    # Test edge cases
    test_name = metadata.get('test_name', 'unknown')
    
    if 'exactly 0.5' in test_name:
        # Test half-up rounding behavior
        assert actual_decimal == Decimal('0.5')
        print(f"✓ Half-up rounding test passed: {actual_decimal}")
    
    elif 'very small value' in test_name:
        # Test very small values
        assert actual_decimal > 0
        assert actual_decimal < Decimal('0.00000001')  # Less than 1e-8
        print(f"✓ Small value test passed: {actual_decimal}")
    
    elif 'large value' in test_name:
        # Test large values
        assert actual_decimal > Decimal('1000000000')  # Greater than 1 billion
        print(f"✓ Large value test passed: {actual_decimal}")
    
    elif 'high precision' in test_name:
        # Test high precision
        # Check that we have the expected number of decimal places
        decimal_str = str(actual_decimal)
        if '.' in decimal_str:
            decimal_places = len(decimal_str.split('.')[1])
            assert decimal_places <= expected_scale, f"Too many decimal places: {decimal_places} > {expected_scale}"
        print(f"✓ High precision test passed: {actual_decimal} (scale: {expected_scale})")
    
    print(f"✓ Precision test passed for {test_name}")
    print(f"  Expected: scaled={expected_scaled}, scale={expected_scale}")
    print(f"  Actual: scaled={actual_scaled}, scale={actual_scale}")
    print(f"  Decimal: {actual_decimal}")


def test_rounding_behavior():
    """Test specific rounding behaviors."""
    print("Testing rounding behaviors...")
    
    # Test cases for half-up rounding
    test_cases = [
        (5, 1, Decimal('0.5')),      # 0.5 should round up to 1
        (4, 1, Decimal('0.4')),      # 0.4 should round down to 0
        (15, 1, Decimal('1.5')),     # 1.5 should round up to 2
        (14, 1, Decimal('1.4')),     # 1.4 should round down to 1
    ]
    
    for scaled, scale, expected in test_cases:
        # This would test the actual rounding implementation
        # For now, we just validate the test cases are correct
        actual = Decimal(scaled) / (Decimal(10) ** scale)
        assert actual == expected, f"Rounding test case failed: {scaled}/{10**scale} = {actual}, expected {expected}"
    
    print("✓ Rounding behavior tests passed")


def main():
    if len(sys.argv) != 3:
        print("Usage: python3 precision_test.py <proto_file> <meta_file>")
        print("  proto_file: path to .pb file")
        print("  meta_file: path to .json metadata file")
        sys.exit(1)
    
    proto_file = sys.argv[1]
    meta_file = sys.argv[2]
    
    # Validate files exist
    if not os.path.exists(proto_file):
        print(f"ERROR: Proto file not found: {proto_file}")
        sys.exit(1)
    
    if not os.path.exists(meta_file):
        print(f"ERROR: Metadata file not found: {meta_file}")
        sys.exit(1)
    
    try:
        # Set high precision for decimal calculations
        getcontext().prec = 50
        
        test_numeric_precision(proto_file, meta_file)
        test_rounding_behavior()
        
        print("✓ All precision tests passed!")
        
    except Exception as e:
        print(f"ERROR: Precision test failed: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
