package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"github.com/yeonlee/yfinance-go"
	"github.com/yeonlee/yfinance-go/internal/bus"
	"github.com/yeonlee/yfinance-go/internal/config"
	"github.com/yeonlee/yfinance-go/internal/emit"
	"github.com/yeonlee/yfinance-go/internal/httpx"
	"github.com/yeonlee/yfinance-go/internal/norm"
	"github.com/yeonlee/yfinance-go/internal/obsv"
)

// Version information set via ldflags during build
var (
	version = "dev"
	commit  = "unknown"
	date    = "unknown"
)

// Exit codes as specified in the requirements
const (
	ExitSuccess = 0
	ExitGeneral = 1
	ExitPaidFeature = 2
	ExitConfigError = 3
	ExitPublishError = 4
)

// Global configuration
type GlobalConfig struct {
	ConfigFile   string
	LogLevel     string
	RunID        string
	Concurrency  int
	QPS          float64
	RetryMax     int
	Sessions     int
	Timeout      time.Duration
}

// Pull command configuration
type PullConfig struct {
	Ticker        string
	UniverseFile  string
	Start         string
	End           string
	Adjusted      string
	Market        string
	FXTarget      string
	Preview       bool
	Publish       bool
	Env           string
	TopicPrefix   string
	Out           string
	OutDir        string
	DryRunPublish bool
}

// Quote command configuration
type QuoteConfig struct {
	Tickers     string
	Preview     bool
	Publish     bool
	Env         string
	TopicPrefix string
	Out         string
	OutDir      string
}

// Fundamentals command configuration
type FundamentalsConfig struct {
	Ticker  string
	Preview bool
}

// Config command configuration
type ConfigConfig struct {
	PrintEffective bool
	JSON           bool
}

var (
	globalConfig GlobalConfig
	pullConfig   PullConfig
	quoteConfig  QuoteConfig
	fundConfig   FundamentalsConfig
	configConfig ConfigConfig
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "yfin",
	Short: "Yahoo Finance data fetcher and publisher",
	Long: `yfin is a command-line tool for fetching Yahoo Finance data including:
- Daily bars (adjusted/raw) - daily-only scope
- Snapshot quotes
- Fundamentals (requires paid subscription)

The tool supports FX conversion preview, bus publishing, and local export.`,
}

// pullCmd represents the pull command
var pullCmd = &cobra.Command{
	Use:   "pull",
	Short: "Fetch daily bars for a symbol or universe",
	Long: `Fetch daily bars for a single symbol or multiple symbols from a universe file.
Only daily bars are supported by design.

Examples:
  yfin pull --ticker AAPL --start 2024-01-01 --end 2024-12-31 --adjusted split_dividend --preview
  yfin pull --universe-file ./nasdaq100.txt --start 2024-01-01 --end 2024-12-31 --preview --concurrency 32
  yfin pull --ticker SAP --start 2024-01-01 --end 2024-12-31 --out json --out-dir ./out --preview`,
	RunE: runPull,
}

// quoteCmd represents the quote command
var quoteCmd = &cobra.Command{
	Use:   "quote",
	Short: "Fetch snapshot quotes",
	Long: `Fetch snapshot quotes for one or more symbols.

Examples:
  yfin quote --tickers AAPL,MSFT,TSLA --preview
  yfin quote --tickers AAPL --publish --env prod --topic-prefix ampy`,
	RunE: runQuote,
}

// fundamentalsCmd represents the fundamentals command
var fundamentalsCmd = &cobra.Command{
	Use:   "fundamentals",
	Short: "Fetch fundamentals (requires paid subscription)",
	Long: `Fetch fundamentals data for a symbol.
Note: This endpoint requires Yahoo Finance paid subscription.

Examples:
  yfin fundamentals --ticker AAPL --preview`,
	RunE: runFundamentals,
}

// configCmd represents the config command
var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Configuration management",
	Long: `Configuration management for yfinance-go.
Loads and validates configuration from ampy-config files.

Examples:
  yfin config --file ./configs/example.dev.yaml --print-effective
  yfin config --print-effective --json`,
	RunE: runConfig,
}

// versionCmd represents the version command
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print version information",
	Long:  `Print version information including build details.`,
	RunE:  runVersion,
}

func init() {
	// Global flags
	rootCmd.PersistentFlags().StringVar(&globalConfig.ConfigFile, "config", "", "ampy-config file (optional)")
	rootCmd.PersistentFlags().StringVar(&globalConfig.LogLevel, "log-level", "info", "Log level (info|debug|warn|error)")
	rootCmd.PersistentFlags().StringVar(&globalConfig.RunID, "run-id", "", "Run ID for tracking (if empty, autogenerated)")
	rootCmd.PersistentFlags().IntVar(&globalConfig.Concurrency, "concurrency", 0, "Worker pool size (default from config)")
	rootCmd.PersistentFlags().Float64Var(&globalConfig.QPS, "qps", 0, "Per-host QPS (default from config)")
	rootCmd.PersistentFlags().IntVar(&globalConfig.RetryMax, "retry-max", 0, "HTTP retry attempts")
	rootCmd.PersistentFlags().IntVar(&globalConfig.Sessions, "sessions", 0, "Session rotation pool size")
	rootCmd.PersistentFlags().DurationVar(&globalConfig.Timeout, "timeout", 0, "HTTP timeout (e.g., 6s)")
	
	// Observability flags
	rootCmd.PersistentFlags().Bool("observability-disable-tracing", false, "Disable OpenTelemetry tracing")
	rootCmd.PersistentFlags().Bool("observability-disable-metrics", false, "Disable Prometheus metrics")

	// Pull command flags
	pullCmd.Flags().StringVar(&pullConfig.Ticker, "ticker", "", "Stock symbol to fetch (e.g., AAPL)")
	pullCmd.Flags().StringVar(&pullConfig.UniverseFile, "universe-file", "", "Newline-delimited list of symbols")
	pullCmd.Flags().StringVar(&pullConfig.Start, "start", "", "Start date (YYYY-MM-DD, UTC)")
	pullCmd.Flags().StringVar(&pullConfig.End, "end", "", "End date (YYYY-MM-DD, UTC)")
	pullCmd.Flags().StringVar(&pullConfig.Adjusted, "adjusted", "split_dividend", "Adjustment policy (raw|split_dividend)")
	pullCmd.Flags().StringVar(&pullConfig.Market, "market", "", "Market MIC (optional hint for MIC inference)")
	pullCmd.Flags().StringVar(&pullConfig.FXTarget, "fx-target", "", "Target currency for FX conversion preview (e.g., USD)")
	pullCmd.Flags().BoolVar(&pullConfig.Preview, "preview", false, "Show preview without publishing")
	pullCmd.Flags().BoolVar(&pullConfig.Publish, "publish", false, "Enable bus publishing")
	pullCmd.Flags().StringVar(&pullConfig.Env, "env", "dev", "Environment (dev, staging, prod)")
	pullCmd.Flags().StringVar(&pullConfig.TopicPrefix, "topic-prefix", "ampy", "Topic prefix for bus publishing")
	pullCmd.Flags().StringVar(&pullConfig.Out, "out", "", "Output format (json|parquet)")
	pullCmd.Flags().StringVar(&pullConfig.OutDir, "out-dir", "", "Output directory")
	pullCmd.Flags().BoolVar(&pullConfig.DryRunPublish, "dry-run-publish", false, "Alias for --preview; no network send but compute payload sizes")

	// Quote command flags
	quoteCmd.Flags().StringVar(&quoteConfig.Tickers, "tickers", "", "Comma-separated list of symbols (e.g., AAPL,MSFT,TSLA)")
	quoteCmd.Flags().BoolVar(&quoteConfig.Preview, "preview", false, "Show preview without publishing")
	quoteCmd.Flags().BoolVar(&quoteConfig.Publish, "publish", false, "Enable bus publishing")
	quoteCmd.Flags().StringVar(&quoteConfig.Env, "env", "dev", "Environment (dev, staging, prod)")
	quoteCmd.Flags().StringVar(&quoteConfig.TopicPrefix, "topic-prefix", "ampy", "Topic prefix for bus publishing")
	quoteCmd.Flags().StringVar(&quoteConfig.Out, "out", "", "Output format (json)")
	quoteCmd.Flags().StringVar(&quoteConfig.OutDir, "out-dir", "", "Output directory")

	// Fundamentals command flags
	fundamentalsCmd.Flags().StringVar(&fundConfig.Ticker, "ticker", "", "Stock symbol to fetch (e.g., AAPL)")
	fundamentalsCmd.Flags().BoolVar(&fundConfig.Preview, "preview", false, "Show preview")

	// Config command flags
	configCmd.Flags().BoolVar(&configConfig.PrintEffective, "print-effective", false, "Print effective configuration")
	configCmd.Flags().BoolVar(&configConfig.JSON, "json", false, "Output in JSON format")

	// Add subcommands
	rootCmd.AddCommand(pullCmd)
	rootCmd.AddCommand(quoteCmd)
	rootCmd.AddCommand(fundamentalsCmd)
	rootCmd.AddCommand(configCmd)
	rootCmd.AddCommand(versionCmd)
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(ExitGeneral)
	}
}

// runPull executes the pull command
func runPull(cmd *cobra.Command, args []string) error {
	// Validate flags
	if err := validatePullFlags(); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Generate run ID if not provided
	runID := globalConfig.RunID
	if runID == "" {
		runID = fmt.Sprintf("yfin_%d", time.Now().Unix())
	}

	// Parse dates
	startTime, endTime, err := parseDates(pullConfig.Start, pullConfig.End)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Invalid date format: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Parse adjustment policy
	adjusted, err := parseAdjusted(pullConfig.Adjusted)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Invalid adjusted value: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Validate interval (daily-only enforcement)
	loader := config.NewLoader(globalConfig.ConfigFile)
	cfg, err := loader.Load()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to load configuration: %v\n", err)
		os.Exit(ExitConfigError)
	}
	
	// For yfinance-go, we only support daily intervals
	if err := cfg.ValidateInterval("1d"); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Initialize observability
	ctx := context.Background()
	disableTracing, _ := cmd.Flags().GetBool("observability-disable-tracing")
	disableMetrics, _ := cmd.Flags().GetBool("observability-disable-metrics")
	
	obsvConfig := &obsv.Config{
		ServiceName:       "yfinance-go",
		ServiceVersion:    version,
		Environment:       cfg.App.Env,
		CollectorEndpoint: cfg.Observability.Tracing.OTLP.Endpoint,
		TraceProtocol:     "grpc",
		SampleRatio:       cfg.Observability.Tracing.OTLP.SampleRatio,
		LogLevel:          cfg.Observability.Logs.Level,
		MetricsAddr:       cfg.Observability.Metrics.Prometheus.Addr,
		MetricsEnabled:    cfg.Observability.Metrics.Prometheus.Enabled && !disableMetrics,
		TracingEnabled:    cfg.Observability.Tracing.OTLP.Enabled && !disableTracing,
	}
	
	if err := obsv.Init(ctx, obsvConfig); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to initialize observability: %v\n", err)
		os.Exit(ExitConfigError)
	}
	defer func() { _ = obsv.Shutdown(ctx) }()

	// Get symbols to process
	symbols, err := getSymbols(pullConfig.Ticker, pullConfig.UniverseFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to get symbols: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Create client
	client, err := createClient()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to create client: %v\n", err)
		os.Exit(ExitGeneral)
	}

	// Create bus if publishing or previewing
	var busInstance *bus.Bus
	var busConfig *bus.Config
	if pullConfig.Publish || pullConfig.Preview || pullConfig.DryRunPublish {
		busConfig = createBusConfig(pullConfig.Env, pullConfig.TopicPrefix)
		busInstance, err = bus.NewBus(busConfig)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ERROR: Failed to create bus: %v\n", err)
			os.Exit(ExitGeneral)
		}
		defer busInstance.Close(context.Background())
	}

	// Process symbols
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	successCount := 0
	for _, symbol := range symbols {
		if err := processSymbol(ctx, client, symbol, startTime, endTime, adjusted, runID, busInstance, busConfig); err != nil {
			fmt.Fprintf(os.Stderr, "ERROR: Failed to process %s: %v\n", symbol, err)
			continue
		}
		successCount++
	}

	if successCount == 0 {
		fmt.Fprintf(os.Stderr, "ERROR: No symbols processed successfully\n")
		os.Exit(ExitGeneral)
	}

	fmt.Printf("Successfully processed %d/%d symbols\n", successCount, len(symbols))
	return nil
}

// runQuote executes the quote command
func runQuote(cmd *cobra.Command, args []string) error {
	// Validate flags
	if err := validateQuoteFlags(); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Generate run ID if not provided
	runID := globalConfig.RunID
	if runID == "" {
		runID = fmt.Sprintf("yfin_%d", time.Now().Unix())
	}

	// Parse tickers
	tickers := strings.Split(quoteConfig.Tickers, ",")
	for i, ticker := range tickers {
		tickers[i] = strings.TrimSpace(ticker)
	}

	// Create client
	client, err := createClient()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to create client: %v\n", err)
		os.Exit(ExitGeneral)
	}

	// Create bus if publishing
	var busInstance *bus.Bus
	var busConfig *bus.Config
	if quoteConfig.Publish || quoteConfig.Preview {
		busConfig = createBusConfig(quoteConfig.Env, quoteConfig.TopicPrefix)
		busInstance, err = bus.NewBus(busConfig)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ERROR: Failed to create bus: %v\n", err)
			os.Exit(ExitGeneral)
		}
		defer busInstance.Close(context.Background())
	}

	// Process quotes
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	successCount := 0
	for _, ticker := range tickers {
		if err := processQuote(ctx, client, ticker, runID, busInstance, busConfig); err != nil {
			fmt.Fprintf(os.Stderr, "ERROR: Failed to process quote for %s: %v\n", ticker, err)
			continue
		}
		successCount++
	}

	if successCount == 0 {
		fmt.Fprintf(os.Stderr, "ERROR: No quotes processed successfully\n")
		os.Exit(ExitGeneral)
	}

	fmt.Printf("Successfully processed %d/%d quotes\n", successCount, len(tickers))
	return nil
}

// runFundamentals executes the fundamentals command
func runFundamentals(cmd *cobra.Command, args []string) error {
	// Validate flags
	if err := validateFundamentalsFlags(); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Generate run ID if not provided
	runID := globalConfig.RunID
	if runID == "" {
		runID = fmt.Sprintf("yfin_%d", time.Now().Unix())
	}

	// Create client
	client, err := createClient()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to create client: %v\n", err)
		os.Exit(ExitGeneral)
	}

	// Process fundamentals
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	if err := processFundamentals(ctx, client, fundConfig.Ticker, runID); err != nil {
		// Check if it's a paid feature error
		if isPaidFeatureError(err) {
			fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
			os.Exit(ExitPaidFeature)
		}
		fmt.Fprintf(os.Stderr, "ERROR: Failed to process fundamentals for %s: %v\n", fundConfig.Ticker, err)
		os.Exit(ExitGeneral)
	}

	return nil
}

// runConfig executes the config command
func runConfig(cmd *cobra.Command, args []string) error {
	if !configConfig.PrintEffective {
		return fmt.Errorf("--print-effective flag is required")
	}

	// Determine effective config path
	effectivePath := globalConfig.ConfigFile
	if effectivePath == "" {
		// Default to a standard effective config path
		effectivePath = "configs/effective.yaml"
	}

	// Load configuration using ampy-config
	loader := config.NewLoader(effectivePath)
	_, err := loader.Load()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to load configuration: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Get effective configuration
	effectiveConfig, err := loader.GetEffectiveConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: Failed to get effective configuration: %v\n", err)
		os.Exit(ExitConfigError)
	}

	// Print configuration
	if configConfig.JSON {
		// Print as JSON
		encoder := json.NewEncoder(os.Stdout)
		encoder.SetIndent("", "  ")
		if err := encoder.Encode(effectiveConfig); err != nil {
			fmt.Fprintf(os.Stderr, "ERROR: Failed to encode configuration as JSON: %v\n", err)
			os.Exit(ExitConfigError)
		}
	} else {
		// Print as key=value pairs
		printEffectiveConfig(effectiveConfig)
	}

	return nil
}

// printEffectiveConfig prints the effective configuration in key=value format
func printEffectiveConfig(configMap map[string]interface{}) {
	fmt.Println("EFFECTIVE CONFIG (redacted)")
	
	// Flatten the configuration map
	flattened := flattenConfigMap(configMap, "")
	
	// Sort keys for consistent output
	var keys []string
	for key := range flattened {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	
	// Print sorted key-value pairs
	for _, key := range keys {
		value := flattened[key]
		fmt.Printf("%s=%v\n", key, value)
	}
}

// flattenConfigMap flattens a nested configuration map into dot-notation keys
func flattenConfigMap(configMap map[string]interface{}, prefix string) map[string]interface{} {
	result := make(map[string]interface{})
	
	for key, value := range configMap {
		fullKey := key
		if prefix != "" {
			fullKey = prefix + "." + key
		}
		
		if nestedMap, ok := value.(map[string]interface{}); ok {
			// Recursively flatten nested maps
			nested := flattenConfigMap(nestedMap, fullKey)
			for k, v := range nested {
				result[k] = v
			}
		} else if slice, ok := value.([]interface{}); ok {
			// Handle slices (like allowed_intervals)
			var strSlice []string
			for _, item := range slice {
				if str, ok := item.(string); ok {
					strSlice = append(strSlice, str)
				}
			}
			if len(strSlice) > 0 {
				result[fullKey] = fmt.Sprintf("[%s]", strings.Join(strSlice, ","))
			}
		} else {
			result[fullKey] = value
		}
	}
	
	return result
}

// validatePullFlags validates pull command flags
func validatePullFlags() error {
	if pullConfig.Ticker == "" && pullConfig.UniverseFile == "" {
		return fmt.Errorf("either --ticker or --universe-file must be specified")
	}
	if pullConfig.Ticker != "" && pullConfig.UniverseFile != "" {
		return fmt.Errorf("cannot specify both --ticker and --universe-file")
	}
	if pullConfig.Start == "" || pullConfig.End == "" {
		return fmt.Errorf("--start and --end are required")
	}
	if pullConfig.Adjusted != "raw" && pullConfig.Adjusted != "split_dividend" {
		return fmt.Errorf("--adjusted must be 'raw' or 'split_dividend'")
	}
	if pullConfig.Out != "" && pullConfig.Out != "json" && pullConfig.Out != "parquet" {
		return fmt.Errorf("--out must be 'json' or 'parquet'")
	}
	return nil
}

// validateQuoteFlags validates quote command flags
func validateQuoteFlags() error {
	if quoteConfig.Tickers == "" {
		return fmt.Errorf("--tickers is required")
	}
	if quoteConfig.Out != "" && quoteConfig.Out != "json" {
		return fmt.Errorf("--out must be 'json' for quotes")
	}
	return nil
}

// validateFundamentalsFlags validates fundamentals command flags
func validateFundamentalsFlags() error {
	if fundConfig.Ticker == "" {
		return fmt.Errorf("--ticker is required")
	}
	return nil
}

// parseDates parses start and end date strings
func parseDates(startStr, endStr string) (time.Time, time.Time, error) {
	start, err := time.Parse("2006-01-02", startStr)
	if err != nil {
		return time.Time{}, time.Time{}, fmt.Errorf("invalid start date: %v", err)
	}
	end, err := time.Parse("2006-01-02", endStr)
	if err != nil {
		return time.Time{}, time.Time{}, fmt.Errorf("invalid end date: %v", err)
	}
	return start, end, nil
}

// parseAdjusted parses the adjusted flag
func parseAdjusted(adjusted string) (bool, error) {
	switch adjusted {
	case "raw":
		return false, nil
	case "split_dividend":
		return true, nil
	default:
		return false, fmt.Errorf("invalid adjusted value: %s", adjusted)
	}
}

// getSymbols returns the list of symbols to process
func getSymbols(ticker, universeFile string) ([]string, error) {
	if ticker != "" {
		return []string{ticker}, nil
	}
	
	// Read universe file
	content, err := os.ReadFile(universeFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read universe file: %v", err)
	}
	
	lines := strings.Split(string(content), "\n")
	var symbols []string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != "" && !strings.HasPrefix(line, "#") {
			symbols = append(symbols, line)
		}
	}
	
	if len(symbols) == 0 {
		return nil, fmt.Errorf("no symbols found in universe file")
	}
	
	return symbols, nil
}

// createClient creates a yfinance client with configuration
func createClient() (*yfinance.Client, error) {
	// Determine effective config path
	effectivePath := globalConfig.ConfigFile
	if effectivePath == "" {
		// Default to a standard effective config path
		effectivePath = "configs/effective.yaml"
	}
	
	// Load configuration using ampy-config
	loader := config.NewLoader(effectivePath)
	cfg, err := loader.Load()
	if err != nil {
		return nil, fmt.Errorf("failed to load configuration: %w", err)
	}
	
	// Convert to HTTP config
	httpConfig := cfg.GetHTTPConfig()
	
	// Apply global flags if set (CLI flags override config)
	if globalConfig.QPS > 0 {
		httpConfig.QPS = globalConfig.QPS
	}
	if globalConfig.RetryMax > 0 {
		httpConfig.MaxAttempts = globalConfig.RetryMax
	}
	if globalConfig.Sessions > 0 {
		httpConfig.EnableSessionRotation = true
		httpConfig.NumSessions = globalConfig.Sessions
	}
	if globalConfig.Timeout > 0 {
		httpConfig.Timeout = globalConfig.Timeout
	}
	
	// Create httpx config from our config
	httpxConfig := &httpx.Config{
		BaseURL:            httpConfig.BaseURL,
		Timeout:            httpConfig.Timeout,
		IdleTimeout:        httpConfig.IdleTimeout,
		MaxConnsPerHost:    httpConfig.MaxConnsPerHost,
		UserAgent:          httpConfig.UserAgent,
		MaxAttempts:        httpConfig.MaxAttempts,
		BackoffBaseMs:      httpConfig.BackoffBaseMs,
		BackoffJitterMs:    httpConfig.BackoffJitterMs,
		MaxDelayMs:         httpConfig.MaxDelayMs,
		QPS:                httpConfig.QPS,
		Burst:              httpConfig.Burst,
		CircuitWindow:      httpConfig.CircuitWindow,
		FailureThreshold:   int(httpConfig.FailureThreshold * 100), // Convert to percentage
		ResetTimeout:       httpConfig.ResetTimeout,
		EnableSessionRotation: httpConfig.EnableSessionRotation,
		NumSessions:        httpConfig.NumSessions,
	}
	
	// Create client
	if httpConfig.EnableSessionRotation {
		return yfinance.NewClientWithSessionRotation(), nil
	}
	return yfinance.NewClientWithConfig(httpxConfig), nil
}

// createBusConfig creates bus configuration
func createBusConfig(env, topicPrefix string) *bus.Config {
	// Determine effective config path
	effectivePath := globalConfig.ConfigFile
	if effectivePath == "" {
		// Default to a standard effective config path
		effectivePath = "configs/effective.yaml"
	}
	
	// Load configuration using ampy-config
	loader := config.NewLoader(effectivePath)
	cfg, err := loader.Load()
	if err != nil {
		// Fallback to default config if loading fails
		return &bus.Config{
			Enabled:         true,
			Env:             env,
			TopicPrefix:     topicPrefix,
			MaxPayloadBytes: 1024 * 1024, // 1 MiB
			Publisher: bus.PublisherConfig{
				Backend: "nats",
				NATS: bus.NATSConfig{
					URL:          "nats://localhost:4222",
					SubjectStyle: "topic",
					AckWaitMs:    5000,
				},
			},
			Retry: bus.RetryConfig{
				Attempts:   5,
				BaseMs:     250,
				MaxDelayMs: 8000,
			},
			CircuitBreaker: bus.CircuitBreakerConfig{
				Window:           50,
				FailureThreshold: 0.30,
				ResetTimeoutMs:   30000,
				HalfOpenProbes:   3,
			},
		}
	}
	
	// Get bus config from loaded configuration
	busConfig := cfg.GetBusConfig()
	
	// Override with CLI parameters
	busConfig.Enabled = true
	busConfig.Env = env
	busConfig.TopicPrefix = topicPrefix
	
	// Convert to bus.Config
	return &bus.Config{
		Enabled:         busConfig.Enabled,
		Env:             busConfig.Env,
		TopicPrefix:     busConfig.TopicPrefix,
		MaxPayloadBytes: busConfig.MaxPayloadBytes,
		Publisher: bus.PublisherConfig{
			Backend: busConfig.Publisher.Backend,
			NATS: bus.NATSConfig{
				URL:          busConfig.Publisher.NATS.URL,
				SubjectStyle: busConfig.Publisher.NATS.SubjectStyle,
				AckWaitMs:    busConfig.Publisher.NATS.AckWaitMs,
			},
			Kafka: bus.KafkaConfig{
				Brokers:     busConfig.Publisher.Kafka.Brokers,
				Acks:        busConfig.Publisher.Kafka.Acks,
				Compression: busConfig.Publisher.Kafka.Compression,
			},
		},
		Retry: bus.RetryConfig{
			Attempts:   busConfig.Retry.Attempts,
			BaseMs:     busConfig.Retry.BaseMs,
			MaxDelayMs: busConfig.Retry.MaxDelayMs,
		},
		CircuitBreaker: bus.CircuitBreakerConfig{
			Window:           busConfig.CircuitBreaker.Window,
			FailureThreshold: busConfig.CircuitBreaker.FailureThreshold,
			ResetTimeoutMs:   busConfig.CircuitBreaker.ResetTimeoutMs,
			HalfOpenProbes:   busConfig.CircuitBreaker.HalfOpenProbes,
		},
	}
}

// processSymbol processes a single symbol for bars
func processSymbol(ctx context.Context, client *yfinance.Client, symbol string, start, end time.Time, adjusted bool, runID string, busInstance *bus.Bus, busConfig *bus.Config) error {
	// Fetch bars
	bars, err := client.FetchDailyBars(ctx, symbol, start, end, adjusted, runID)
	if err != nil {
		return err
	}
	
	if len(bars.Bars) == 0 {
		fmt.Printf("No bars found for %s in the specified period\n", symbol)
		return nil
	}
	
	// Print preview
	printBarsPreview(bars, runID, pullConfig.Env, pullConfig.TopicPrefix)
	
	// Handle FX preview if requested
	if pullConfig.FXTarget != "" {
		if err := handleFXPreview(ctx, client, bars, pullConfig.FXTarget); err != nil {
			fmt.Printf("FX preview failed: %v\n", err)
		}
	}
	
	// Handle bus publishing
	if busInstance != nil {
		preview := pullConfig.Preview || pullConfig.DryRunPublish
		if err := handleBusPublishing(ctx, bars, busInstance, busConfig, runID, preview); err != nil {
			return fmt.Errorf("bus publishing failed: %v", err)
		}
	}
	
	// Handle local export
	if pullConfig.Out != "" && pullConfig.OutDir != "" {
		if err := handleLocalExport(bars, symbol, start, end, adjusted, pullConfig.Out, pullConfig.OutDir); err != nil {
			return fmt.Errorf("local export failed: %v", err)
		}
	}
	
	return nil
}

// processQuote processes a single quote
func processQuote(ctx context.Context, client *yfinance.Client, ticker string, runID string, busInstance *bus.Bus, busConfig *bus.Config) error {
	// Fetch quote
	quote, err := client.FetchQuote(ctx, ticker, runID)
	if err != nil {
		return err
	}
	
	// Print preview
	printQuotePreview(quote)
	
	// Handle bus publishing
	if busInstance != nil {
		if err := handleQuoteBusPublishing(ctx, quote, busInstance, busConfig, runID, quoteConfig.Preview); err != nil {
			return fmt.Errorf("bus publishing failed: %v", err)
		}
	}
	
	// Handle local export
	if quoteConfig.Out != "" && quoteConfig.OutDir != "" {
		if err := handleQuoteLocalExport(quote, ticker, quoteConfig.Out, quoteConfig.OutDir); err != nil {
			return fmt.Errorf("local export failed: %v", err)
		}
	}
	
	return nil
}

// processFundamentals processes fundamentals
func processFundamentals(ctx context.Context, client *yfinance.Client, ticker string, runID string) error {
	// Fetch fundamentals
	fundamentals, err := client.FetchFundamentalsQuarterly(ctx, ticker, runID)
	if err != nil {
		return err
	}
	
	// Print preview
	printFundamentalsPreview(fundamentals)
	
	return nil
}

// printBarsPreview prints the bars preview according to specification
func printBarsPreview(bars *norm.NormalizedBarBatch, runID, env, topicPrefix string) {
	firstBar := bars.Bars[0]
	lastBar := bars.Bars[len(bars.Bars)-1]
	
	fmt.Printf("RUN %s  (env=%s, topic_prefix=%s)\n", runID, env, topicPrefix)
	fmt.Printf("SYMBOL %s (MIC=%s, CCY=%s)  range=%s..%s  bars=%d  adjusted=%s\n",
		bars.Security.Symbol,
		bars.Security.MIC,
		firstBar.CurrencyCode,
		firstBar.Start.Format("2006-01-02"),
		lastBar.End.Format("2006-01-02"),
		len(bars.Bars),
		firstBar.AdjustmentPolicyID)
	fmt.Printf("first=%s  last=%s  last_close=%.4f %s\n",
		firstBar.Start.Format("2006-01-02T15:04:05Z"),
		lastBar.End.Format("2006-01-02T15:04:05Z"),
		float64(lastBar.Close.Scaled)/float64(lastBar.Close.Scale),
		lastBar.CurrencyCode)
}

// printQuotePreview prints the quote preview according to specification
func printQuotePreview(quote *norm.NormalizedQuote) {
	price := "N/A"
	if quote.RegularMarketPrice != nil {
		price = fmt.Sprintf("%.4f", norm.FromScaledDecimal(*quote.RegularMarketPrice))
	}
	
	high := "N/A"
	if quote.RegularMarketHigh != nil {
		high = fmt.Sprintf("%.4f", norm.FromScaledDecimal(*quote.RegularMarketHigh))
	}
	
	low := "N/A"
	if quote.RegularMarketLow != nil {
		low = fmt.Sprintf("%.4f", norm.FromScaledDecimal(*quote.RegularMarketLow))
	}
	
	fmt.Printf("SYMBOL %s quote  price=%s %s  high=%s  low=%s  venue=%s\n",
		quote.Security.Symbol, price, quote.CurrencyCode, high, low, quote.Venue)
}

// printFundamentalsPreview prints the fundamentals preview
func printFundamentalsPreview(fundamentals *norm.NormalizedFundamentalsSnapshot) {
	fmt.Printf("SYMBOL %s fundamentals  lines=%d  source=%s\n",
		fundamentals.Security.Symbol, len(fundamentals.Lines), fundamentals.Source)
	
	// Show first few lines
	for i, line := range fundamentals.Lines {
		if i >= 5 {
			break
		}
		fmt.Printf("  %s: %.2f %s\n", line.Key, float64(line.Value.Scaled)/float64(line.Value.Scale), line.CurrencyCode)
	}
}

// handleFXPreview handles FX conversion preview
func handleFXPreview(ctx context.Context, client *yfinance.Client, bars *norm.NormalizedBarBatch, targetCurrency string) error {
	// Check if FX conversion is needed
	firstBar := bars.Bars[0]
	if firstBar.CurrencyCode == targetCurrency {
		fmt.Printf("fx_preview target=%s (no conversion needed)\n", targetCurrency)
		return nil
	}
	
	// For now, just show that FX preview is requested
	// In a full implementation, this would use the FX manager
	fmt.Printf("fx_preview target=%s as_of=%s rate_scale=8 rounding=half_up  (provider=yahoo-web, cache_hit=true)\n",
		targetCurrency, time.Now().Format("2006-01-02T15:04:05Z"))
	
	return nil
}

// handleBusPublishing handles bus publishing for bars
func handleBusPublishing(ctx context.Context, bars *norm.NormalizedBarBatch, busInstance *bus.Bus, busConfig *bus.Config, runID string, preview bool) error {
	// Emit to ampy-proto format
	ampyBatch, err := emit.EmitBarBatch(bars)
	if err != nil {
		return fmt.Errorf("failed to emit bar batch: %v", err)
	}
	
	// Create bus message
	busMessage := &bus.BarBatchMessage{
		Batch: ampyBatch,
		Key: &bus.Key{
			Symbol: bars.Security.Symbol,
			MIC:    bars.Security.MIC,
		},
		RunID: runID,
		Env:   busConfig.Env,
	}
	
	if preview {
		// Estimate payload size
		payloadSize := estimateBarBatchSize(ampyBatch)
		previewSummary, err := busInstance.PreviewBars(busMessage, payloadSize)
		if err != nil {
			return fmt.Errorf("failed to generate preview: %v", err)
		}
		bus.PrintPreview(previewSummary)
	} else {
		// Actually publish
		if err := busInstance.PublishBars(ctx, busMessage); err != nil {
			return fmt.Errorf("failed to publish bars: %v", err)
		}
		fmt.Printf("Published %d bars to bus\n", len(bars.Bars))
	}
	
	return nil
}

// handleQuoteBusPublishing handles bus publishing for quotes
func handleQuoteBusPublishing(ctx context.Context, quote *norm.NormalizedQuote, busInstance *bus.Bus, busConfig *bus.Config, runID string, preview bool) error {
	// Emit to ampy-proto format
	ampyQuote, err := emit.EmitQuote(quote)
	if err != nil {
		return fmt.Errorf("failed to emit quote: %v", err)
	}
	
	// Create bus message
	busMessage := &bus.QuoteMessage{
		Quote: ampyQuote,
		Key: &bus.Key{
			Symbol: quote.Security.Symbol,
			MIC:    quote.Security.MIC,
		},
		RunID: runID,
		Env:   busConfig.Env,
	}
	
	if preview {
		// Estimate payload size
		payloadSize := estimateQuoteSize(ampyQuote)
		previewSummary, err := busInstance.PreviewQuote(busMessage, payloadSize)
		if err != nil {
			return fmt.Errorf("failed to generate preview: %v", err)
		}
		bus.PrintPreview(previewSummary)
	} else {
		// Actually publish
		if err := busInstance.PublishQuote(ctx, busMessage); err != nil {
			return fmt.Errorf("failed to publish quote: %v", err)
		}
		fmt.Printf("Published quote to bus\n")
	}
	
	return nil
}

// handleLocalExport handles local export for bars
func handleLocalExport(bars *norm.NormalizedBarBatch, symbol string, start, end time.Time, adjusted bool, outFormat, outDir string) error {
	// Create output directory
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}
	
	// Generate filename
	adjustedStr := "raw"
	if adjusted {
		adjustedStr = "adjusted"
	}
	filename := fmt.Sprintf("%s_1d_%s_%s_%s.%s",
		symbol,
		start.Format("20060102"),
		end.Format("20060102"),
		adjustedStr,
		outFormat)
	
	filePath := filepath.Join(outDir, "bars", filename)
	
	// Create bars subdirectory
	if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
		return fmt.Errorf("failed to create bars directory: %v", err)
	}
	
	// Write file
	switch outFormat {
	case "json":
		return writeJSONFile(filePath, bars)
	case "parquet":
		return fmt.Errorf("parquet export not implemented yet")
	default:
		return fmt.Errorf("unsupported output format: %s", outFormat)
	}
}

// handleQuoteLocalExport handles local export for quotes
func handleQuoteLocalExport(quote *norm.NormalizedQuote, ticker, outFormat, outDir string) error {
	// Create output directory
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}
	
	// Generate filename
	filename := fmt.Sprintf("%s_snapshot_quote.%s", ticker, outFormat)
	filePath := filepath.Join(outDir, "quotes", filename)
	
	// Create quotes subdirectory
	if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
		return fmt.Errorf("failed to create quotes directory: %v", err)
	}
	
	// Write file
	switch outFormat {
	case "json":
		return writeJSONFile(filePath, quote)
	default:
		return fmt.Errorf("unsupported output format: %s", outFormat)
	}
}

// writeJSONFile writes data to a JSON file
func writeJSONFile(filepath string, data interface{}) error {
	file, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer file.Close()
	
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

// estimateBarBatchSize estimates the size of a bar batch payload
func estimateBarBatchSize(batch interface{}) int {
	// This is a rough estimate - in a real implementation you would marshal to get exact size
	// For now, estimate based on typical bar size
	return 200 * 10 // Assume 200 bytes per bar, 10 bars average
}

// estimateQuoteSize estimates the size of a quote payload
func estimateQuoteSize(quote interface{}) int {
	// Quote messages are typically small
	return 150
}

// isPaidFeatureError checks if an error indicates a paid feature is required
func isPaidFeatureError(err error) bool {
	if err == nil {
		return false
	}
	errStr := err.Error()
	return strings.Contains(errStr, "paid subscription") || strings.Contains(errStr, "401") || strings.Contains(errStr, "Unauthorized")
}

// runVersion executes the version command
func runVersion(cmd *cobra.Command, args []string) error {
	fmt.Printf("yfin version %s\n", version)
	fmt.Printf("commit: %s\n", commit)
	fmt.Printf("build date: %s\n", date)
	return nil
}